---
title: 'FECONF 2022'
description: 'B TRACK'
coverImage: '/assets/blog/retrospects/FECONF-2022/cover.png'
category: '회고'
date: '2022/10/08'
path: 'retrospects'
---

# FECONF 2022

# ReScript 같이 해요 (정미량 - 그린랩스)

![같이해요](/assets/blog/retrospects/FECONF-2022/1.png)

> 💡 예상 청자
> 비기너, 새로운 언어, 함수형 프로그래밍, 강력한 타입 언어

## ReScript 가볍게 알아보기

읽을 수 있는 자바스크립트로 컴파일되는 강력한 타입 언어
자바스크립트의 모든 라이브러리를 사용가능

## ReScript 첫인상

- 불변성으로 변수를 변경하지 못한다는점이 조금 어색했다
- let만 있다. (재할당 불가능)
- 화살표 사용 → 파이프 연산자
- return이 없다 → 마지막 라인은 암묵적 반환
- import & export가 없다 → 모든 모듈은 내보내진다.
- 타입 어노테이션 없이도 타입이 있다,. → 타입 추론 가능

## ReScript 작게 좋았던 점
- 빌트인 포매터 제공 → 프레임워크처럼 논쟁할 필요가 없구나
- 좌에서 우로, 위에서 아래로 읽기
    - 파이프 연산자 → 책 읽듯 한 방향으로 읽는게 가능
- export & import 신경 안쓰기
    - 모든 모듈이 내보내지기 때문에 파일명이 중복이 되면 안됨, 찾기가 편함
    - 자동으로 프로젝트 안에서 모듈을 찾아서 import 한 파일의 위치가 바껴도 코드가 바뀌지 않는다.

## ReScript 크게 좋았던 점
- 타입 추론 시스템
    - 모든 표현식의 타입을 힌들리 - 밀너 타입 추론으로 확인
    - 레코드 타입 선언도 자동적으로 찾아줌
    - 신기한 타입 Variant
        - 패턴 매칭 - 데이터 형태 따른 스위치 구문
        - ReScript에서 스위치는 표현식이기 때문에 변수에 할당가능
    - Null
        - ReScript는 null, undefined에 대한 개념이 없다.
        - 옵션타입으로 정의가능

## ReScript 아직도 망설인다면?
- 점진적 채택
    - 프로젝트에 부분적으로 적용하기

## ReScript 아쉬웠던 점
- 바인딩
    - rescripts-bindings
- 커뮤니티가 작다.
    - ReScript Forum을 참고하자

## 마무리
- Relay를 같이 사용하는건 어떨까요?

```shell
$ yarn add --dev rescript
$ npm install rescript --save-dev
```

## 질문 타임
타입스크립트에서도 함수형 관련 라이브러리들이 많이 생겨나고 있는데, ReScript를 하고 있는데 바인딩과 같은 어려운 개념이 있으면 지속가능한게 어려울 것 같은데, 혹시 지속가능한지 방향성을 생각하고 있는지?
    - 바인딩이 어렵지만 익숙해지면 괜찮다.
    - 타입스크립트로 작성된 것들은 정의(데피니션)이 있어서 리스크립트 도입이 변경이 쉽다.
    - 리스크립트 계속 사용할 예정이다.

## 느낀점

발표가 되게 깔끔했다.

점진적 도입을 해서 개인 프로젝트에서 도입을 할 수 있을 것 같다.
모든 구성원들의 동의가 없으면 회사에서 도입은 조금 힘들지 않을까?

# @webtoon/psd 오픈소스 라이브러리 개발기 (이동현/강예형 - 네이버웹툰)

![psd](/assets/blog/retrospects/FECONF-2022/2.png)

> 해당 발표는 [네이버 기술 블로그](https://d2.naver.com/helloworld/6631477)에 이미 나와있습니다.

## 개발 배경

웹툰 원고를 포토샵으로 보통 받기 때문에, 포토샵 파일을 파싱하면 다양한 정보를 얻을 수 있다.

```html
<input type="file"  accept="adobe/photo">
```

웹 어플리케이션에서 포토샵 파일을 읽는 방법
- 서버에 업로드해서 파일을 분석하고 메타데이터와 이미지 다운로드
		- 파이썬 라이브러리를 이용한다.
- 웹 브라우저에서 바로 파일을 분석
		- 네트워크 호출 비용이 없다

psd.js라는 라이브러리가 있었지만 우리의 요구사항과 맞지 않아 사용하지 않음.

- 번들링 용량: 용량이 너무 커...
- 실행 속도: 실행 속도가 너무 느려...
- .psb 형식 미지원
- ❗️ 한글 미지원 ❗️

그래서 우리는 이렇게 바꿨다.

- 번들링 용량은 1/10의 크기
- 7배정도의 속도 향상
- psb 파일 지원
- 유니코드 문자 지원: 한글, 한자 모두 지원가능

## 포토샵 파일 톺아보기

공식문서에서 자세하게 확인가능

- 공식문서 양이 진짜 많은데, 그 덕분에 라이브러리를 만들 때 참고를 많이했다.

그 다음엔 포토샵 파일의 각각의 섹션에 대해서 설명을 해주심.
(공식문서에 다 나와있음)

- 파일 헤더, 컬러 메타 데이터, 이미지에 관한 것, 그리고 최종적인 이미지 데이터(미리보기 이미지) 등등에 대한 정보들이 포토샵 파일에 들어가있다.

그 이후에는 바이너리 데이터를 읽는 방식들을 설명해주심

- input type file로 받고, array buffer로 받을 수 있다.

높이 정보를 얻는 방법, 그리고 위치 정보를 바이너리 데이터로 읽는 방법을 설명해주심
그리고 "2의 보수"를 오랜만에 들었다...

포토샵에서는 또 DataView 내장 객체를 제공해준다.
DataView 객체를 쓰는 방법을 알려주심

Cursor 객체를 직접 만들어서 비트를 읽어낼 위치값을 개발자가 계속 추적하긴 어려우니까, 스스로 위치를 기억하고 인덱스를 갱신하는 객체를 활용했다.

발표자 교체

## 성능

### psd 파서, 빨라지다.

기존의 psd 파서는 너무 느렸다.
원래는 15초에 읽혀지는 것을 1초로 바꿨는데 요기에 만족하지 못함.

### 병목을 찾아라.

어떤 병목이 시간을 느리게 하는가? => 이미지 데이터 디코딩에 많은 시간이 소요된다.

기존 압축방식은 `Run-Length Encoding` 을 사용하고 있다.
이 알고리즘에는 한계가 있다.

자바스크립트를 버리고 고수준의 언어를 사용했다.
웹 어셈블리를 사용했다.

### WebAssembly

- 웹 브라우저에서 고성능 작업을 위한 기술
- 기계어에 가까운 저수준의 바이트코드를 실행
- JS보다 빠른 해독과 최적화

### WebAssembly 특징

- 다른 언어로 만든 코드를 WebAssembly 바이트코드로 컴파일
- .wasm 확장자로 나옴
- JS와는 독립적인 메모리 공간을 사용한다 -> 성능 손실 발생
- 실행하기 위해 JS의 도움이 필요하다 -> 개발, 배포 과정이 복잡해짐

### WebAssembly 동작방식

### WebAssembly 코드 실행 방식

- wasm 파일의 내용을 불러온다.

### 라이브러리 개발자의 고민

- 다양한 환경에서 우리 라이브러리를 쓰게 하고 싶다.
- 실행 환경마다 wasm 파일을 불러오는 방식이 다름
- 실행 환경을 탐지해서 적절한 파일 로딩 방식을 쓰자

번들러에 대한 고민
- 여러 JS 파일을 하나의 JS 파일로 합침
- 특정 라이브러리를 사용하면 호환성 이슈가 발생한다. (Webpack, Parcel, Rollup...)

그래서 base64 인코딩을 해서, 그냥 문자열로 저장하고 모듈 로딩 시 바이너리 데이터로 변한환 다음 WebAssembly를 실행한다.

그래서 번들링 문제를 해결할 수 있었다. 근데 바이너리 데이터를 문자열로 바꾸는 과정에서 모듈 로딩이 오래 걸린다. 그리고 번들이 커진다.

## Toolchains

WebAssembly을 개발하기 위해 Rust 언어를 채택
번들러로 Vite를 사용해서 모듈을 임베드했다.

## 결과

기대했던 것 만큼의 속도 향상은 없었다. (약 10%)

크롬이 최적화가 원래 잘 되어있다.
파이어폭스랑 사파리는 그래서 속도 향상이 많았다. (60% - 100%)

## 교훈

- 크롬의 JS 최적화는 무시할 수 없다.
- 크로스 브라우징을 고려한다면 WebAssembly가 유리하다
- 개발 비용과 난이도가 만만치 않다.

그래서 개발 비용이랑 여러 가지 상황들을 고려해서 적용하자.

webtoon/psd 라이브러리 참고! TODO: 

## 질문

Q: 다음에 성능 개선할 경우가 있으면 WebAssembly를 다시 사용할 건가요?
A: 자바스크립트에서 최대한의 성능 개선을 뽑아내고, 그 다음에 WebAssembly을 고려해볼 것 같다.

Q: WebAssembly를 도입하시면서 도입을 시도하는 기준이 생기셨을 것 같아요. 혹시 생기셨나요?
A: 단순히 코드가 빨라지는 것은 아니고 CPU 연산을 많이 하는 처리들? 복잡한 파일 압축등등은 WebAssembly으로 바꿨을 때 성능 개선이 크다. DOM, file과 같은 처리들은 굳이 바꿀 필요가 없을 것 같다.

## 느낀점

두 발표자가 나와서 번갈아가면서 발표를 했음. 신기했음. 환기가 전환되는 느낌이 있었다.

지금 당장 내가 포토샵 파일을 파싱하고 바이너리 데이터를 읽을 일은 없겠지만,
하나의 깊은 분야에 대해서 어떤식으로 문제 해결을 해나가는지에 대한 인사이트를 얻을 수 있었다.
문제를 인식하고, 공식 문서를 찾아보고, 해결법을 찾고 그걸 코드로 보여주는 과정까지.

# 프론트엔드 DDD를 만나다. (박세문 - 라포랩스)

## 왜 DDD에 대해서 이야기를 하는가?

세가지로 얘기 가능

- 복잡성 (Complexity)
- 의사소통 (Communicatios)
- 유사성 (Similarity)

위의 세가지를 해결해줄 수 있다고 생각.

DDD는 같은 언어로 함께 일할 수 있게 도와주는 역할을 한다.

Redux vs CQRS Pattern
리덕스와 비교하면서 CQRS에 대해서 설명
이벤트를 디스패치하면서 이펙트를 일으키는 것이 리덕스의 액션 디스패치와 비슷
Agrregate는 reducer와 비슷하다

## DDD란 무엇일까?

## 어떻게 DDD를 적용할 수 있을까?

### 미리 짚고 넘어가는 개념들

실제 세상의 Product를 만드는데 집중한다.

Stractegic Design / Tactical Design으로 나눌 수 있다.
이 둘을 이용해서 Hexagonal을 얘기한다.

Stractegic Design

https://www.martinfowler.com/bliki/BoundedContext.html

유비쿼터스 언어
- 팀 내에서 모두가 이해하는 공통된 언어
- 문서/워크플로우/스펙/코드에 까지 공통된 용어를 정의하고 사용하게 해야한다.
- 용어사전을 만들고 모두 함께 사용가능하게 해야한다.
- 마크다운을 이용해서도 만들 수 있을 것 같다.

택티컬 디자인
DDD의 리소스들의 모음이라고 얘기할 수 있다.
다섯가지 개념이 있다. 엔티티, 벨류 오브젝트, 어그리게이트, 서비스, 도메인 이벤트

엔티티
- 유일한 식별자
- 고유한 수명을 가짐

벨류 오브젝트
- 엔티티와 유사하지만 변경할 수 없는 Immutable하다.
- 식별자가 없다.

어그리게이트
- 가장 중요하고 복잡한 패턴 중 하나다

서비스
- 도메인, 어플리케이션으로 크게 나뉨
- 도메인: 비즈니스 로직, 도메인 동작
- 어플리케이션: 어플리케이션 로직

도메인 이벤트
- 카운트 어플리케이션을 예시로 듦
- click 이벤트를 통해서 도메인 이벤트가 발생

### Layered 구조

4가지 계층으로 구성됨
User Interface - Application - Domain - Infrastructure

### Hexagonal 구조

바깥에서 안으로만 가는 단방향 구조를 가짐
User Interface - Adapter(추가) - Application - Domain - Infrastructure

부분적인 수정이 발생했을 때 어플리케이션 전체가 바뀌지 않아도 되고, 부분적으로 대응이 가능하다.

## 설계시간

## Problems

여러 도메인이 동일한 프레젠테이션 컴포넌트를 필요로 할 경우라면?
여러 도메인이 동일한 컨테이너 컴포넌트를 필요로 할 경우라면?
여러 도메인이 동일한 API 호출한다면?
여러 도메인이 동일한 hook이나 helper function을 사용한다면?

## DDD는 항상 옳을까?

학습해야할 것도 많고, 과정도 많기 때문에
관심있는 도메인을 보다 명확히 분리하는 것이 중요하다.

단순히 프론트와 백엔드에 CRUD로만 소통한다면 DDD는 필요없다.
CRUD만 있다면 그냥 예쁜 데이터베이스 테이블 편집기만 있으면 된다.

DDD의 이점을 가져가려면, DDD의 학습 비용보다 DDD를 적용함으로써 얻는게 많아야
적용하는게 좋을 것 같다.

## 질문 타임

Q: 헥사고날로 적용했을 때 타입 폭발, 인터페이스 폭발을 줄일 수 있는 방법이 있을까요?

A: 지속적으로 타입, 인터페이스를 관리할 수 있는 시간을 가지면 어떨까.
예전 회사에서는 지속적으로 타입, 인터페이스만 보는 사람이 있었다. 지속적으로 모델을 관리하고 폭발적인 증가를 리팩토링하는 노력이 필요하다.

## 느낀점

사실 잘 모르겠다... 아직 이걸 들을만한 실력이 되지 않았나보다.
뒤에 설계를 직접 코드로 보여주시는 부분에서 조금 이해가 되었따.
핵심은 각각의 레이어에서 변경이 있어도 다른 레이어에 영향을 최소한으로 줄 수 있다는 것.
의존성을 역시 줄이는 게 좋구나, 변경에 대처할 수 있다.
모든 기술은 무조건이라는 건 없다. 트레이드오프가 존재하기 때문에 잘 알아보고 진짜 필요하다면 공부하며 적용해도 늦지않다.

# 텍스트 에디터? 그게 뭘 만드는 건데? (노용구 - 네이버)

React + contenteditabl

## Intro

IDE, 노션 등등 에디터는 많다.
에디터는 어떻게 만들어졌을까?

- 커서 이동
- 사진 편집
- 글씨 볼드체
- etc...

이 모든 것들은 당연한 것이 아니다.

## 스마트에디터로 살펴본 에디터의 발전

> 스마트에디터를 기준으로 설명

각 세대별로 특징들이 있다. (1, 1.5, 2세대)

### 1세대 에디터

특징
- contenteditable 컨텐츠를 편집 가능하게 해주는 HTML 속성사용
- HTML 그대로 출력해준다.

```html
<div contenteditable="true">
```

한계
- 멀티 디바이스 대응이 어렵다.

### 1.5세대 에디터

특징
- 문서 모델링: JSON으로 편집가능
- 블록별 편집

한계
- Selection 동작이 어색하다.

### 2세대 에디터

특징

가상 커서
- 가상 커서는 svg, animation을 이용해서 구현
- vscode도 가상커서이다.

input buffer
- input buffer는 input이 바깥에 하나 더 존재한다.
- input 영역을 따로 가져간다.

한계

- 브라우저 네이티브 활용이 어려움
	- 다국어 이슈
	- 우 클릭 붙여넣기 이슈

## 새로운 에디터로의 도전

React + MobX + contenteditable을 사용

### 기존 에디터의 사용성 유저하기

장소 첨부, 컴포넌트 레이아웃도 변경 가능
가상 커서도 사용중

### 브라우저 네이티브 활용 어려움 해소하기

contenteditable을 사용하자!
- 브라우저에 기댈 수 있음
- 브라우저 지원 범위가 축소되었다. (IE 지원 종료)

### 우리가 흐름을 제어하자!

문제: contenteditable과 react를 함께 사용해 DOM과 vDOM 싱크 문제 발생
해결: DOM과 vDOM 싱크가 깨질 만한 상황은 나누어 관리하자.

싱크가 꺠질만한 상황이 생기면 contenteditable에서 DOM조작은 하지말고,
리액트의 store에서 DOM 변경만을 한다.

또한 글을 쓸 때는 리액트의 반응을 끊고, contenteditable의 변경만으로 DOM을 업데이트한다.

업스트림, 다운스트림으로 나눠서 contenteditable을 통해서 DOM이 업데이트 될 것인지,
React를 통해서 DOM이 업데이트 될 것인지를 나눠서 관리한다.

## 질문 타임

Q: 예전에 노션을 참고하셨나요?
A: 예전에는 참고했다. 블록별 편집, 커서가 갇혀있었다. 요즘엔 잘 지원됐다.

Q: 스트림을 나눠서 개발을 할 때 리액트의 상태와 contenteditable의 상태가 따로 존재하나?
A: 일치한다. 우리가 직접 HTML을 관리하는 방식으로 진행한다.

Q: 커서 관련, 이동했을 때 커서의 크기는 어떻게 계산하나?
A: 클릭은 이진탐색을 해서 x,y,z를 계산해서 어떤 p가 존재하고, offset은 얼마인지 가상커서를 직접 그리게 된다.

Q: 업스트림, 다운스트림은 어떤 기준으로 나눴는지?
A: 업스트림은 타자치는 것, 다운스트림 엔터와 같은 태그가 삽입되는 것 (왜냐하면 브라우저마다 추가되는 태그가 다르다.)

## 느낀점

최고 스마트 에디터야! 고맙다!
나를 위해 많은 것들을 해주고 있었구나.

DOM과 vDOM의 싱크가 깨지는 것을 해결하는 방식이 되게 신선했다.

# Edge Computing으로 프론트엔드 포텐셜 끌어올리기 (김혜성 - 당근마켓)



## 느낀점
